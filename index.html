<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="UTF-8">
    <title>Go-kalmanfilter by shantanubhadoria</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="stylesheets/normalize.css" media="screen">
    <link href='https://fonts.googleapis.com/css?family=Open+Sans:400,700' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="stylesheets/github-light.css" media="screen">
  </head>
  <body>
    <section class="page-header">
      <h1 class="project-name">Go-kalmanfilter</h1>
      <h2 class="project-tagline">Golang Library for Kalman Filter(also known as Linear Quadratic Estimation) implementation for sensor fusion</h2>
      <a href="https://github.com/shantanubhadoria/go-kalmanfilter" class="btn">View on GitHub</a>
      <a href="https://github.com/shantanubhadoria/go-kalmanfilter/zipball/master" class="btn">Download .zip</a>
      <a href="https://github.com/shantanubhadoria/go-kalmanfilter/tarball/master" class="btn">Download .tar.gz</a>
    </section>

    <section class="main-content">
      <h1>
<a id="kalmanfilter" class="anchor" href="#kalmanfilter" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>kalmanfilter</h1>

<h2></h2>

<pre><code>import "github.com/shantanubhadoria/go-kalmanfilter/kalmanfilter"
</code></pre>

<p>Package kalmanfilter implements Kalman Filter(Linear Quadratic Estimation)
support for Go language</p>

<p><a href="https://travis-ci.org/shantanubhadoria/go-kalmanfilter"><img src="https://img.shields.io/travis/shantanubhadoria/go-kalmanfilter.svg?style=flat-square" alt="Travis CI"></a> <a href="https://godoc.org/github.com/shantanubhadoria/go-kalmanfilter/kalmanfilter"><img src="https://godoc.org/github.com/shantanubhadoria/go-kalmanfilter/kalmanfilter?status.svg" alt="GoDoc"></a></p>

<h3>
<a id="introduction" class="anchor" href="#introduction" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Introduction</h3>

<p>Source and Bug reports at <a href="https://github.com/shantanubhadoria/go-kalmanfilter">https://github.com/shantanubhadoria/go-kalmanfilter</a></p>

<h3>
<a id="synopsis" class="anchor" href="#synopsis" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Synopsis</h3>

<pre><code>package main

import (
  "fmt"
  "time"
  "github.com/shantanubhadoria/go-kalmanfilter/"
)

myFilterData = new(kalmanfilter.FilterData)

var oldTime time.Time = time.Now()
for {
  stateReading := float64(getStateSensorReading()) // in units X
  deltaReading := float64(getDeltaSensorReading()) // in unit X per nanosecond

  var newTime time.Time = time.Now()
  var duration Duration = newTime.Sub(oldTime)
  oldTime = newTime
  newState := myFilterData.Update(stateReading, deltaReading, int64(duration/time.Nanosecond))
  fmt.Println(newState)
}
</code></pre>

<h3>
<a id="description" class="anchor" href="#description" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Description</h3>

<p>The Kalman filter(<a href="https://en.wikipedia.org/wiki/Kalman_filter">https://en.wikipedia.org/wiki/Kalman_filter</a>), also known as
linear quadratic estimation (LQE), is an algorithm that uses a series of
measurements observed over time, containing noise (random variations) and other
inaccuracies, and produces estimates of unknown variables that tend to be more
precise than those based on a single measurement alone.</p>

<p>Algorithm is recursive, which means it takes the output of its previous
calculations as a factor in calculating the next step which improves its
accuracy over time. The key to Kalman filters are two sensors with different
kind of accuracy issues in each. Sensor A or the state sensor might give
in-accurate value for a measurement on the whole but it doesn't drift. Sensor B
or delta sensor gives gives much more accurate rate of change in value(or delta)
but it drifts over time due to its small inaccuracies as it only measures rate
of change in value and not the actual value. Kalman filter uses this knowledge
to fuse results from both sensors to give a state value which is more accurate
than state value received from any of these filters alone.</p>

<p>An example of application for this is calculating orientation of objects using
Gyroscopes and Accelerometers.</p>

<p>While Accelerometer is usually used to measure gravity it can be used to measure
the inclination of a body with respect to the surface of earth along the x and y
axis(not z axis as Z axis faces the direction opposite the direction of
gravitional force) by measuring the direction in which the force of gravity is
felt.</p>

<p>Gyroscope measures the rate of rotation about one or all the axes of a body.
While it gives fairly accurate estimation of the angular velocity, if we use it
to calculate the current inclination based on the starting inclination and the
angular velocity, there is a lot of drift, which means the gyroscope error will
accumulate over time as we calculate newer angles based on previous angle and
angular velocity and the error in angular velocity piles on leading to
increasingly inaccurate estimations as time passes.</p>

<p>A real life example of how Kalman filter works is noticed while driving on a
highway in a car. If you take the time passed since when your started driving
and your estimated average speed since then and use it to calculate the distance
you have traveled your calculation will become more inaccurate as time passes.</p>

<p>This is drift in value. However if you correct based on each milestone marker
that you pass through and re-calculate your distance travelled using milestone
data and your average speed since you pass the last milestone your result will
be much more accurate irrespective of how much time has passed. That is
approximately close to how Kalman filter and sensor fusion work.</p>

<p>State Sensor: <img src="/corpus/milestone.jpg" alt="Milestone"></p>

<p>Delta Sensor: <img src="/corpus/speedometer.png" alt="Speedometer"></p>

<h3>
<a id="author" class="anchor" href="#author" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Author</h3>

<p>Shantanu Bhadoria  <a href="https://www.shantanubhadoria.com">https://www.shantanubhadoria.com</a></p>

<h2>
<a id="usage" class="anchor" href="#usage" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>Usage</h2>

<h4>
<a id="type-filterdata" class="anchor" href="#type-filterdata" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>type FilterData</h4>

<div class="highlight highlight-source-go"><pre><span class="pl-k">type</span> <span class="pl-v">FilterData</span> <span class="pl-k">struct</span> {

    <span class="pl-c">/*</span>
<span class="pl-c">       State the state sensor value. In a IMU this would be the</span>
<span class="pl-c">       Accelerometer</span>
<span class="pl-c">    */</span>
    <span class="pl-v">State</span> <span class="pl-k">float64</span>

    <span class="pl-c">/*</span>
<span class="pl-c">       Bias: the delta sensor error. This is the deviation</span>
<span class="pl-c">       from sensor reading and actual value. Bias can be caused by</span>
<span class="pl-c">       electromagnetic interference and represents a permanent error</span>
<span class="pl-c">       in delta sensor reading. Bias is detected by averaging the</span>
<span class="pl-c">       delta sensor reading at stationary state of delta sensor</span>
<span class="pl-c">    */</span>
    <span class="pl-v">Bias</span> <span class="pl-k">float64</span>

    <span class="pl-c">/*</span>
<span class="pl-c">       Covariance Matrix a 2d 2x2 matrix (also known as dispersion</span>
<span class="pl-c">       matrix or variance-covariance matrix) is a matrix whose</span>
<span class="pl-c">       element in the i, j position is the covariance between the i</span>
<span class="pl-c">       and j elements of a random vector. Leave this at default</span>
<span class="pl-c">       value of [[0,0],[0,0]]</span>
<span class="pl-c">    */</span>
    <span class="pl-v">Covariance</span> [<span class="pl-c1">2</span>][<span class="pl-c1">2</span>]<span class="pl-k">float64</span>

    <span class="pl-v">QAngle</span>   <span class="pl-k">float64</span>
    <span class="pl-v">QBias</span>    <span class="pl-k">float64</span>
    <span class="pl-v">RMeasure</span> <span class="pl-k">float64</span>
}</pre></div>

<p>FilterData struct, initialize this struct before commencing any operations, as
sensors are read, this struct must be updated alongside</p>

<h4>
<a id="func-filterdata-update" class="anchor" href="#func-filterdata-update" aria-hidden="true"><span aria-hidden="true" class="octicon octicon-link"></span></a>func (*FilterData) Update</h4>

<div class="highlight highlight-source-go"><pre><span class="pl-k">func</span> <span class="pl-en">(<span class="pl-v">filterData</span> *<span class="pl-v">FilterData</span>) <span class="pl-en">Update</span></span>(<span class="pl-v">stateReading</span>, <span class="pl-v">deltaReading</span>, <span class="pl-v">deltaTime</span> <span class="pl-v">float64</span>) <span class="pl-v">float64</span></pre></div>

<p>Call this method to update the state value based on sensor fusion of state and
delta sensor and the previously calculated reading to get progressively more
accurate state values</p>

      <footer class="site-footer">
        <span class="site-footer-owner"><a href="https://github.com/shantanubhadoria/go-kalmanfilter">Go-kalmanfilter</a> is maintained by <a href="https://github.com/shantanubhadoria">shantanubhadoria</a>.</span>

        <span class="site-footer-credits">This page was generated by <a href="https://pages.github.com">GitHub Pages</a> using the <a href="https://github.com/jasonlong/cayman-theme">Cayman theme</a> by <a href="https://twitter.com/jasonlong">Jason Long</a>.</span>
      </footer>

    </section>

  
  </body>
</html>
