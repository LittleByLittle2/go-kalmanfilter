{
  "name": "Go-kalmanfilter",
  "tagline": "Golang Library for Kalman Filter(also known as Linear Quadratic Estimation) implementation for sensor fusion",
  "body": "# kalmanfilter\r\n--\r\n    import \"github.com/shantanubhadoria/go-kalmanfilter/kalmanfilter\"\r\n\r\nPackage kalmanfilter implements Kalman Filter(Linear Quadratic Estimation)\r\nsupport for Go language\r\n\r\n[![Travis CI](https://img.shields.io/travis/shantanubhadoria/go-kalmanfilter.svg?style=flat-square)](https://travis-ci.org/shantanubhadoria/go-kalmanfilter) [![GoDoc](https://godoc.org/github.com/shantanubhadoria/go-kalmanfilter/kalmanfilter?status.svg)](https://godoc.org/github.com/shantanubhadoria/go-kalmanfilter/kalmanfilter)\r\n\r\n### Introduction\r\n\r\nSource and Bug reports at https://github.com/shantanubhadoria/go-kalmanfilter\r\n\r\n### Synopsis\r\n\r\n    package main\r\n\r\n    import (\r\n      \"fmt\"\r\n      \"time\"\r\n      \"github.com/shantanubhadoria/go-kalmanfilter/\"\r\n    )\r\n\r\n    myFilterData = new(kalmanfilter.FilterData)\r\n\r\n    var oldTime time.Time = time.Now()\r\n    for {\r\n      stateReading := float64(getStateSensorReading()) // in units X\r\n      deltaReading := float64(getDeltaSensorReading()) // in unit X per nanosecond\r\n\r\n      var newTime time.Time = time.Now()\r\n      var duration Duration = newTime.Sub(oldTime)\r\n      oldTime = newTime\r\n      newState := myFilterData.Update(stateReading, deltaReading, int64(duration/time.Nanosecond))\r\n      fmt.Println(newState)\r\n    }\r\n\r\n\r\n### Description\r\n\r\nThe Kalman filter(https://en.wikipedia.org/wiki/Kalman_filter), also known as\r\nlinear quadratic estimation (LQE), is an algorithm that uses a series of\r\nmeasurements observed over time, containing noise (random variations) and other\r\ninaccuracies, and produces estimates of unknown variables that tend to be more\r\nprecise than those based on a single measurement alone.\r\n\r\nAlgorithm is recursive, which means it takes the output of its previous\r\ncalculations as a factor in calculating the next step which improves its\r\naccuracy over time. The key to Kalman filters are two sensors with different\r\nkind of accuracy issues in each. Sensor A or the state sensor might give\r\nin-accurate value for a measurement on the whole but it doesn't drift. Sensor B\r\nor delta sensor gives gives much more accurate rate of change in value(or delta)\r\nbut it drifts over time due to its small inaccuracies as it only measures rate\r\nof change in value and not the actual value. Kalman filter uses this knowledge\r\nto fuse results from both sensors to give a state value which is more accurate\r\nthan state value received from any of these filters alone.\r\n\r\nAn example of application for this is calculating orientation of objects using\r\nGyroscopes and Accelerometers.\r\n\r\nWhile Accelerometer is usually used to measure gravity it can be used to measure\r\nthe inclination of a body with respect to the surface of earth along the x and y\r\naxis(not z axis as Z axis faces the direction opposite the direction of\r\ngravitional force) by measuring the direction in which the force of gravity is\r\nfelt.\r\n\r\nGyroscope measures the rate of rotation about one or all the axes of a body.\r\nWhile it gives fairly accurate estimation of the angular velocity, if we use it\r\nto calculate the current inclination based on the starting inclination and the\r\nangular velocity, there is a lot of drift, which means the gyroscope error will\r\naccumulate over time as we calculate newer angles based on previous angle and\r\nangular velocity and the error in angular velocity piles on leading to\r\nincreasingly inaccurate estimations as time passes.\r\n\r\nA real life example of how Kalman filter works is noticed while driving on a\r\nhighway in a car. If you take the time passed since when your started driving\r\nand your estimated average speed since then and use it to calculate the distance\r\nyou have traveled your calculation will become more inaccurate as time passes.\r\n\r\nThis is drift in value. However if you correct based on each milestone marker\r\nthat you pass through and re-calculate your distance travelled using milestone\r\ndata and your average speed since you pass the last milestone your result will\r\nbe much more accurate irrespective of how much time has passed. That is\r\napproximately close to how Kalman filter and sensor fusion work.\r\n\r\nState Sensor: ![Milestone](/corpus/milestone.jpg)\r\n\r\nDelta Sensor: ![Speedometer](/corpus/speedometer.png)\r\n\r\n\r\n### Author\r\n\r\nShantanu Bhadoria <shantanu att cpan dot org> https://www.shantanubhadoria.com\r\n\r\n## Usage\r\n\r\n#### type FilterData\r\n\r\n```go\r\ntype FilterData struct {\r\n\r\n\t/*\r\n\t   State the state sensor value. In a IMU this would be the\r\n\t   Accelerometer\r\n\t*/\r\n\tState float64\r\n\r\n\t/*\r\n\t   Bias: the delta sensor error. This is the deviation\r\n\t   from sensor reading and actual value. Bias can be caused by\r\n\t   electromagnetic interference and represents a permanent error\r\n\t   in delta sensor reading. Bias is detected by averaging the\r\n\t   delta sensor reading at stationary state of delta sensor\r\n\t*/\r\n\tBias float64\r\n\r\n\t/*\r\n\t   Covariance Matrix a 2d 2x2 matrix (also known as dispersion\r\n\t   matrix or variance-covariance matrix) is a matrix whose\r\n\t   element in the i, j position is the covariance between the i\r\n\t   and j elements of a random vector. Leave this at default\r\n\t   value of [[0,0],[0,0]]\r\n\t*/\r\n\tCovariance [2][2]float64\r\n\r\n\tQAngle   float64\r\n\tQBias    float64\r\n\tRMeasure float64\r\n}\r\n```\r\n\r\nFilterData struct, initialize this struct before commencing any operations, as\r\nsensors are read, this struct must be updated alongside\r\n\r\n#### func (*FilterData) Update\r\n\r\n```go\r\nfunc (filterData *FilterData) Update(stateReading, deltaReading, deltaTime float64) float64\r\n```\r\nCall this method to update the state value based on sensor fusion of state and\r\ndelta sensor and the previously calculated reading to get progressively more\r\naccurate state values\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}