{
  "name": "Go-kalmanfilter",
  "tagline": "Golang Library for Kalman Filter(also known as Linear Quadratic Estimation) implementation for sensor fusion",
  "body": "# kalmanfilter\r\n--\r\n    import \"github.com/shantanubhadoria/go-kalmanfilter/kalmanfilter\"\r\n\r\n### Introduction\r\n\r\nPackage kalmanfilter implements Kalman Filter(Linear Quadratic Estimation)\r\nsupport for Go language\r\n\r\n[![Travis\r\nCI](https://img.shields.io/travis/shantanubhadoria/go-kalmanfilter.svg?style=flat-square)](https://travis-ci.org/shantanubhadoria/go-kalmanfilter)\r\n\r\nSource and Bug reports at\r\n\r\n    https://github.com/shantanubhadoria/go-math-filter-kalman\r\n\r\n\r\n### Description\r\n\r\nThe Kalman filter(https://en.wikipedia.org/wiki/Kalman_filter), also known as\r\nlinear quadratic estimation (LQE), is an algorithm that uses a series of\r\nmeasurements observed over time, containing noise (random variations) and other\r\ninaccuracies, and produces estimates of unknown variables that tend to be more\r\nprecise than those based on a single measurement alone.\r\n\r\nAlgorithm is recursive, which means it takes the output of its previous\r\ncalculations as a factor in calculating the next step which improves its\r\naccuracy over time. The key to Kalman filters are two sensors with different\r\nkind of accuracy issues in each. Sensor A or the state sensor might give\r\nin-accurate value for a measurement on the whole but it doesn't drift. Sensor B\r\nor delta sensor gives gives much more accurate rate of change in value(or delta)\r\nbut it drifts over time due to its small inaccuracies as it only measures rate\r\nof change in value and not the actual value. Kalman filter uses this knowledge\r\nto fuse results from both sensors to give a state value which is more accurate\r\nthan state value received from any of these filters alone.\r\n\r\nAn example of application for this is calculating orientation of objects using\r\nGyroscopes and Accelerometers.\r\n\r\nWhile Accelerometer is usually used to measure gravity it can be used to measure\r\nthe inclination of a body with respect to the surface of earth along the x and y\r\naxis(not z axis as Z axis is usually facing the opposite direction as the force\r\nof gravity) by measuring the direction in which the force of gravity is applied.\r\n\r\nGyroscope measures the rate of rotation about one or all the axis of a body.\r\nwhile it gives fairly accurate estimation of the angular velocity, if we use it\r\nto calculate the current inclination based on the starting inclination and the\r\nangular velocity, there is a lot of drift, which means the gyroscope error will\r\naccumulate over time as we calculate newer angles based on previous angle and\r\nangular velocity and the error in angular velocity piles on.\r\n\r\nA real life example of how Kalman filter works is while driving on a highway in\r\na car. If you take the time passed since when your started driving and your\r\nestimated average speed every hour and use it to calculate the distance you have\r\ntraveled your calculation will become more inaccurate as you drive on.\r\n\r\nThis is drift in value. However if you watch each milestone and calculate your\r\ncurrent position using milestone data and your speed since the last milestone\r\nyour result will be much more accurate. That is approximately close to how\r\nKalman filter works.\r\n\r\n## Usage\r\n\r\n#### func  UpdateFilter\r\n\r\n```go\r\nfunc UpdateFilter()\r\n```\r\n\r\n#### type FilterData\r\n\r\n```go\r\ntype FilterData struct {\r\n\r\n\t/*\r\n\t   Angle the state sensor value. In a IMU this would be the\r\n\t   Accelerometer\r\n\t*/\r\n\tAngle float64\r\n\r\n\t/*\r\n\t   Bias: the delta sensor calculation. This is the deviation\r\n\t   from last base state value as calculted from the delta\r\n\t   sensor. In a IMU this would be the product of time since\r\n\t   last reading and the delta sensor value\r\n\r\n\t   Bias is recalculated(optimised) at each new sensor reading.\r\n\t*/\r\n\tBias float64\r\n\r\n\t/*\r\n\t   Covariance Matrix a 2d 2x2 matrix (also known as dispersion\r\n\t   matrix or variance-covariance matrix) is a matrix whose\r\n\t   element in the i, j position is the covariance between the i\r\n\t   and j elements of a random vector.\r\n\t*/\r\n\tCovariance [2][2]float64\r\n\r\n\tQAngle   float64\r\n\tQBias    float64\r\n\tRMeasure float64\r\n}\r\n```\r\n\r\nFilterData struct, initialize this struct before commencing any operations, as\r\nsensors are read, this struct must be updated alongside\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}